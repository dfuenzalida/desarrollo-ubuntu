<?xml version="1.0" encoding="ISO-8859-1" ?>
<!-- $Id$ -->

<chapter>
  <title>Empaquetado y distribución de software para Ubuntu</title>

  <para>
  Hemos llegado al punto en que tenemos software con una calidad y robustez suficiente
  como para comenzar a distribuirlo con nuestros usuarios. En este capítulo revisaremos
  el proceso de empaquetar un proyecto de software como un paquete instalable en un
  sistema y de como este paquete se puede colocar en un repositorio de software de forma
  que los usuarios de nuestra aplicación puedan obtener de forma automática las nuevas
  versiones mejoradas y ampliadas de nuestro software ya publicado.
  </para>

  <sect1>
  <title>Entendiendo los paquetes de software</title>
  <para>
  En sistemas basados en Debian (como Ubuntu, Knoppix y otros) el software que se
  instala en nuestros equipos se encuentra agrupado lógicamente en paquetes, que se
  obtienen desde los discos de instalación e Internet. Estos paquetes contienen los
  archivos que se instalan en nuestros sistemas, más cierta información de contexto
  (metadatos) que indican que cada uno de estos componentes de software obedece ciertas
  reglas y cuales son los recursos de los que provee a nuestro sistema.
  </para>

  <para>
  En general, entonces, diremos que un paquete de software es un elemento que se compone
  de un conjunto de archivos a instalar, y que posee información sobre su versión, los
  otros paquetes de software que requiere para funcionar, los recursos que este paquete
  provee para nuestro sistema y eventualmente, con cuales componentes no se lleva bien 
  (porque puede haber incompatibilidades entre 2 componentes diferentes).
  </para>

  <sect2>
  <!-- versiones del software -->
  <title>Versiones de un elemento de software</title>
  <para>
  Los paquetes de software que instalamos y producimos poseen un número de versión que
  sirve para identificar un conjunto de características que ese software posee, en
  términos de funcionalidades, errores corregidos y por corregir, entre otros. Hay una regla
  más o menos genérica que indica que se usa un número mayor de versión para indicar 
  grandes hitos en el desarrollo de un programa, luego un número menor de versión para
  indicar el grado de avance en el desarrollo de funcionalidades entre estos grandes hitos,
  y finalmente, un tercer número que indica correcciones de seguridad hechas a un programa.
  </para>

  <para>
  De esta forma, un programa en la versión <filename>1.5.3</filename> indica que ya se
  alcanzó el primer gran
  hito de desarrollo del programa (<command>1</command>), en camino hacia una versión
  2. El número de versión menor <command>5</command> indica que es la quinta entrega
  de funcionalidades (desde la versión 1.0), y además
  el tercer dígito de versión (<command>3</command>) indica que se han hecho 3
  correcciones importantes de seguridad a la versión 1.5 de este programa.
  </para> 
  </sect2>

  <sect2>
  <!-- dependencias -->
  <title>Dependencias de un elemento de software</title>

  <para>
  En general, el software de nuestros equipos funciona sobre una cantidad bastante de
  otros componentes previamente instalados, de la misma forma en que el techo de una casa
  descansa sobre las murallas, que a su vez, descansan en los cimientos. Así, nuestro
  software funcionará sobre la base de que otros componentes de software ya se encuentren
  instalados.
  </para>
  </sect2>


  </sect1>

  <!-- Creando un paquete de software Debian -->
  <sect1>
  <title>Creación de un paquete de software Debian</title>

  <para>
  Al ser una distribución basada en Debian, la creación de paquetes en Ubuntu utiliza
  el mismo conjunto de herramientas de ayuda para el proceso de empaquetamiento, entre
  las que se encuentran <filename>dh_make</filename>, <filename>dch</filename>,
  <filename>fakeroot</filename> y otros.
  </para>

  <para>
  A diferencia de otros textos publicados en Internet, vamos a cubrir el escenario más
  completo posible, lo que implica que vamos a crear paquetes fuente y binarios que
  utilizarán un esquema de firma digital basada en GNU Privacy Guard (que es una
  implementación libre del
  estándar de firma digital PGP), para que los usuarios de los paquetes que empaquetemos
  puedan obtener las versiones más recientes del software sin advertencias que puedan
  intimidarlos. Si no usamos firmas en el software que empaquetamos y en los repositorios
  de software a crear, el sistema indica una serie de advertencias al usuario (sobre
  el riesgo de instalar software que no ha sido firmado por ningún responsable) que
  pueden despertar suspicacias o rechazo, cada vez que publiquemos una nueva actualización
  de nuestro software.
  </para>

  <sect2>
  <title>Creación de una firma digital con GnuPG</title>

  <para>
  En primer lugar, se requiere instalar y configurar el software requerido para firmar
  digitalmente los archivos. Las herramientas para empaquetamiento y distribución de
  software en Debian y Ubuntu se encuentran bien integradas con GnuPG y es sencillo de
  utilizar.
  </para>

  <para>
 Procedemos a instalar GnuPG:

  <programlisting><![CDATA[$ sudo apt-get install gnupg ]]></programlisting>

  Una buena guía sobre la instalación de GnuPG se encuentra en la siguiente dirección:
  <ulink url="http://www.gnupg.org/(en)/documentation/howtos.html">http://www.gnupg.org/(en)/documentation/howtos.html</ulink>

  </para>


  <!-- TODO: Agregar referencia al HOWTO en http://www.gnupg.org/(en)/documentation/howtos.html -->

  <para>
  Luego de instalado, debemos generar un conjunto de llaves pública y privada con las
  que funciona el mecanismo de firma digital. Para ello, ejecutamos en un terminal:
  <programlisting><![CDATA[$ gpg --gen-key ]]></programlisting>
  </para>

  <para>
  El programa nos preguntará primero sobre el algoritmo a utilizar para la generación de las claves,
  para lo cual dejamos el algoritmo sugerido por omisión. La siguiente pregunta es la longitud de la
  clave, para lo cual también dejamos al largo sugerido. Luego se nos pregunta el tiempo durante el
  cual estas claves serán vigentes. Para efectos prácticos, 6 meses o un año pueden estar bien,
  pero es posible que otras organizaciones o proyectos usen períodos diferentes por motivos de
  seguridad.
  Luego, el programa pide algunos datos del
  usuario para registrar la identificación de quien firma: El nombre, un comentario o alias y una
  dirección de correo electrónico.
  </para>

  <para>
  Finalmente, se pide una contraseña que se utiliza cada vez que se va a firmar. La contraseña
  idealmente debe ser larga, que combine mayúsculas y minúsculas, etc.
  </para>

  <para>
  A continuación, el programa realiza un trabajo que puede demorar algunos momentos y que consiste
  en la generación de la llave pública y privada, que se basa en la generación de números primos
  mediante la recolección de datos más o menos aleatorios como la fecha y hora, carga del procesador,
  memoria utilizada y un largo etcétera. Puede demorar un poco. Para comprobar la firma recien generada,
  se pueden listar las claves junto a un identificador corto que le corresponde a cada una, con el
  siguiente comando:

<programlisting><![CDATA[$ gpg --list-keys
/users/alice/.gnupg/pubring.gpg
---------------------------------------
pub  1024D/BB7576AC 1999-06-04 Alice (Judge) <alice@cyb.org>
sub  1024g/78E9A8FA 1999-06-04
]]></programlisting></para>

  <para>
  Este comando produce un listado, del cual nos interesa el identificador hexadecimal junto
  a la llave pública. En el listado anterior, es el código <filename>BB7576AC</filename>. Conviene
  tener este identifiador a mano a la hora de firmar paquetes y hacer cambios en el repositorio
  que vamos a crear.
  </para>

  <para>
  Un programa que hace todas estas tareas más sencillas, con una interfaz gráfica, es
  <ulink url="http://www.gnome.org/projects/seahorse/">Seahorse</ulink>, y que puede
  verse en la siguiente captura de pantalla.
  </para>

  <para>
  <inlinemediaobject>
    <imageobject><imagedata fileref="img/seahorse1.png" format="PNG" width="6in" /></imageobject>
    <textobject><phrase>Pantalla del programa SeaHorse</phrase></textobject>
  </inlinemediaobject>
  </para>

  <para>Seahorse queda instalado en <command>Aplicaciones - Accesorios - Contraseñas y claves de cifrado</command></para>

  </sect2>

  <sect2>
  <title>Agregar la llave pública a tus proveedores de software de confianza</title>

  <para>
  Para probar la firma digital sobre los paquetes se software que desarrolles, deberás
  agregar tu llave pública al listado de proveedores de software a los que tienes
  confianza. De lo contrario, cada vez que instales software producido por tí, aparecerán
  advertencias indicando que sólo debes instalar programas que vienen de fuentes de confianza.
  </para>

  <para>
  Lo que debes hacer es agregar el archivo con tu llave pública (<filename>pubring.gpg</filename>)
  a la aplicación que se encuentra en <command>Sistema - Administración - 
  Orígenes del Software</command>. En la lengueta <command>Autentificación</command> encontrarás
  el listado de firmas digitales que tu sistema acepta para validar paquetes de software firmados.
  Para agregar tu llave pública, usa el botón <command>Importar Clave</command> para importar el
  archivo <filename>/home/USUARIO/.gnupg/pubring.gpg</filename>. Tu firma debería aparecer en el
  listado, como en la siguiente pantalla:
  </para>

  <para>
  <inlinemediaobject>
    <imageobject><imagedata fileref="img/origenes-del-software1.png" format="PNG" 
     width="6in" /></imageobject>
    <textobject><phrase>Listado de claves GPG de confianza en los orígenes del software</phrase></textobject>
  </inlinemediaobject>
  </para>

  <para>
  El mismo proceso lo puedes realizar usando el comando <command>apt-key add</command> en una shell:
<programlisting><![CDATA[$ sudo apt-key add /home/usuario/.gnupg/pubring.gpg
$ sudo apt-key list
]]></programlisting>
  </para>

  </sect2>

  <sect2>
  <title>Creación de un paquete Debian</title>

  <para>
  Para crear un paquete Debian, el proceso consta de copiar el código fuente de nuestro proyecto
  y agregar unos archivos de datos extras utilizados por las herramientas que forman los paquetes.
  Cuando el código se obtiene desde un tarball o desde un repositorio de código fuente, este proceso
  de agregar archivos de Debian se llama "Debianización". La referencia oficial para la creación
  de paquetes en Debian y Ubuntu es el documento
  <ulink url="http://www.debian.org/doc/maint-guide/">Debian New Maintainers' Guide</ulink> (en inglés).
  </para>

  <para>
  Procederemos a instalar los siguientes paquetes para instalar las utilidades mínimas para construir
  paquetes Debian:

  <programlisting><![CDATA[$ sudo apt-get install dh-make devscripts fakeroot ]]></programlisting>

  (en caso de construir programas a partir de código fuente en C, también se requiere
  instalar el paquete <filename>build-essential</filename>):
  </para>

  <para>
  Para producir el paquete, obtenemos una copia del código fuente de nuestro proyecto en un directorio
  temporal (por ejemplo, <filename>/tmp/debianizando/gtkfilesplitter-0.2</filename>). El directorio debe
  seguir la siguiente convención: [nombre-del-proyecto]-[versión]. En el ejemplo, el nombre del proyecto
  es <filename>gtkfilesplitter</filename> y la versión es la 0.2.
  </para>

  <para>
  En el directorio donde se encuentra el código fuente de nuestro proyecto, ejecutamos

  <programlisting><![CDATA[$ dh_make -c gpl -e usuario@miempresa.com -s --createorig ]]></programlisting>
  </para>

  <para>
  La herramienta <filename>dh_make</filename> agregará los archivos con la información extra para
  producir el paquete en un directorio <filename>debian</filename> en el directorio actual. El
  parámetro <filename>-c</filename> indica el tipo de licencia a utilizar (las opciones con GPL, LGPL,
  entre otras). La dirección de correo del usuario que produce el paquete se especifica con la
  opción <filename>-e</filename>. Para firmar el paquete hemos utilizado la opción <filename>-s</filename>
  (por "sign") y finalmente, es posible que no hayamos generado el directorio con el código fuente
  a partir de un tarball, así que la opción <filename>--createorig</filename> le indica al programa
  que la genere por nosotros.
  </para>

  <para>
  <!-- TODO mejorar descripción de los archivos luego de dh_make -->
  La ejecución del programa deja tras de sí un directorio <filename>debian</filename> con un conjunto
  de archivos con información del paquete que deberíamos modificar, y en el directorio superior, un
  archivo comprimido (con tar y gzip) con el contenido del directorio antes de la Debianización, un
  archivo de cambios y un archivo extra.
  </para>

  <sect3>
    <title>El archivo <filename>debian/changelog</filename></title>

  <para>
  Si es necesario indicar que este paquete tiene algunas correcciones producto de una mejora o debido
  a que se aplicó algún parche, se puede indicar en un archivo de ChangeLog. Existe un utilitario que
  sirve para esto:

  <programlisting><![CDATA[$ dch -i ]]></programlisting>
  </para>

  <para>
  Este programa abrirá el archivo <filename>debian/changelog</filename> del proyecto y agregará unas
  lineas de contexto para poder agregar la lista de cambios de esta versión de nuestro programa.
  Guardamos los cambios al archivo y salimos del editor.
  </para>
  </sect3>

  <sect3>
    <title>El archivo <filename>debian/control</filename></title>
  
  <para>
  El siguiente archivo relevante que debemos modificar es el archivo debian/control, que es el
  que provee información sobre el mantenedor del paquete de software, los paquetes que son necesarios
  al momento de construir el paquete, y las dependencias al momento de ejecutar el software.
  Vale la pena destacar que no necesariamente son iguales. En el software desarrollado en lenguaje
  C es típico que se necesitan bibliotecas para desarrollos (ej. <filename>libXXXYYYZZZ-dev</filename>)
  que luego no son necesarias en tiempo de ejecución.
  </para>

  <para>
  El campo <command>Description</command> sigue una convención: la primera línea, justo después de
  <filename>Description: </filename> contiene una descripción corta (de hasta 60 caracteres), y luego
  una descripción que puede tener varias líneas de hasta 80 caracteres, que comiencen con un espacio
  en blanco. Para hacer un punto aparte se deja una línea con un espacio y un punto.
  </para>

  <para>
  En el caso de nuestro programa de ejemplo, el contenido del archivo debian/control es el siguiente:
<programlisting><![CDATA[Source: gtkfilesplitter
Section: admin
Priority: optional
Maintainer: Denis Fuenzalida <denis.fuenzalida@gmail.com>
Build-Depends: debhelper (>= 5), python-support (>= 0.3)
Standards-Version: 3.7.2.2

Package: gtkfilesplitter
Architecture: any
Depends: ${misc:Depends}, ${shlibs:Depends}, ${python:Depends}, python, python-glade2, python-gtk2
Description: Simple file splitter/joiner with checksum support
 A desktop application to split and join files
 .
 For more information, visit http://code.google.com/p/gtkfilesplitter
]]></programlisting>

  </para>
  </sect3>

  <sect3>
    <title>El archivo <filename>debian/copyright</filename></title>
  <para>
  En general, este archivo debería venir pre-llenado con una plantilla de la licencia que se haya
  seleccionado al momento de invocar a <command>dh_make</command> y sólo será necesario cambiar
  la información de contacto del creador del software y eventualmente revisar que los términos
  de la licencia sean los que el desarrollador ha acordado.
  </para>
  </sect3>

  <sect3>
    <title>El archivo <filename>debian/rules</filename></title>
  <para>
  El archivo <filename>debian/rules</filename> en realidad es un <command>makefile</command> (un
  archivo con instrucciones para GNU Make) que sigue un cierto patrón de comandos que corresponden
  con una gran cantidad de tareas que se realizan al instalar un paquete de software en nuestro
  sistema: desde instalar la documentación (páginas man, etc.), instalar íconos en el menú de
  aplicaciones, instalar bibliotecas, etc.
  </para>

  <para>
  Las tareas a realizar durante la instalación dependen muchísimo de la naturaleza del software
  que desarrollemos y de los componentes formen parte del mismo. Así, es posible que no incluyamos
  archivo de ejemplo, etc. El archivo <filename>rules</filename> creado contiene una gran cantidad
  de tareas que pueden comentarse en caso de que no apliquen. En el caso de mi programa, utilicé
  como plantilla una versión antigua de otro software (Apt On CD), que también esta escrito en Python.
  En realidad lo único especial que hace es invocar a un Makefile en la raíz del proyecto, indicando
  que los archivos creados deben almacenarse en el directorio <filename>debian/gtkfilesplitter</filename>.

  <programlisting><![CDATA[# Archivo debian/rules del proyecto gtkfilesplitter
# ver archivo completo en:
# http://gtkfilesplitter.googlecode.com/svn/trunk/debian/rules

...
install: build
  dh_testdir
  dh_testroot
  dh_clean -k 
  dh_installdirs

  $(MAKE) install DESTDIR=$(CURDIR)/debian/gtkfilesplitter
...
]]></programlisting>

  </para>

  <para>
  Al crear nuestro paquete, una copia de los archivos agregados al sistema se agrega dentro del directorio
  <filename>debian</filename> en un directorio con el mismo nombre del paquete que estamos creando.
  Por ejemplo: si al instalar mi software, copio un ícono en formato PNG en
  <filename>/usr/share/icons/MiIcono.png</filename>, lo que debe hacer el Makefile en realidad es copiarlo
  al directorio <filename>debian/MiPaquete/usr/share/icons/MiIcono.png</filename>.
  </para>

  <para>
  El contenido (comentado) del Makefile en la raíz del proyecto es:
<programlisting><![CDATA[# Traducciones disponibles:
PO = es pl 

PREFIX ?= /usr

all: check po-data
  @echo "Done"
  @echo "Type: make install now"

check:
  @/bin/echo -n "Checking for Python... "
  @which python || ( echo "Not found." && /bin/false )
  @./check.py

# borrar archivos de resplados, etc.
clean:
  find . -type f -iregex '.*~$$'  -print | xargs rm -rf
  find . -type d -iregex '.*\.svn$$'  -print | xargs rm -rf
  find . -type f -iregex '.*\.pyc$$'  -print | xargs rm -rf
  find . -type f -iregex '.*\.gladep$$'  -print | xargs rm -rf
  find . -type f -iregex '.*\.bak$$'  -print | xargs rm -rf

make-install-dirs: make-install-dirs-po

  # Crear directorios para copiar los archivos
  mkdir -p $(DESTDIR)$(PREFIX)/bin
  mkdir -p $(DESTDIR)$(PREFIX)/share/applications
  mkdir -p $(DESTDIR)$(PREFIX)/share/gtkfilesplitter
  mkdir -p $(DESTDIR)$(PREFIX)/share/pixmaps
  mkdir -p $(DESTDIR)$(PREFIX)/share/gnome/help/gtkfilesplitter/C
  mkdir -p $(DESTDIR)$(PREFIX)/share/locale

make-install-dirs-po:

  # Para cada idioma:
  # Crear un directorio para colocar los archivos de traducción
  for lang in $(PO); \
    do mkdir -p $(DESTDIR)$(PREFIX)/share/locale/$$lang/LC_MESSAGES; \
  done

install: make-install-dirs install-po

  # Copiar el ejecutable Python, con permiso de ejecución y lectura para todos
  install -m 755 gtkfilesplitter.py $(DESTDIR)$(PREFIX)/share/gtkfilesplitter

  # Copiar el archivo Glade de interfaz de usuario
  install -m 644 gtkfilesplitter.glade $(DESTDIR)$(PREFIX)/share/gtkfilesplitter

  # Copiar los íconos de la aplicación
  install -m 644 gtkfilesplitter*.png $(DESTDIR)$(PREFIX)/share/gtkfilesplitter

  # Copiar el archivo .desktop (que crea el ícono en el menú)
  install -m 644 gtkfilesplitter.desktop $(DESTDIR)$(PREFIX)/share/applications/

  # Creo un link simbólico al script en /usr/bin
  cd $(DESTDIR)$(PREFIX)/bin && \
  ln -sf ../share/gtkfilesplitter/gtkfilesplitter.py gtkfilesplitter && \
  chmod 755 gtkfilesplitter
    
install-po:
 
  # Instalo los archivos de traducciones (.mo)
  for lang in $(PO); \
    do install -m 644 \
      locale/$$lang/LC_MESSAGES/* \
      $(DESTDIR)$(PREFIX)/share/locale/$$lang/LC_MESSAGES/; \
  done

po-dir:
  for lang in $(PO); do mkdir -p locale/$$lang/LC_MESSAGES/ ; done

po-data: po-dir
  for lang in $(PO); \
    do msgfmt locale/$$lang.po -o \
      locale/$$lang/LC_MESSAGES/gtkfilesplitter.mo; \
  done

po-gen:

  # Generación de archivos .pot y .po a partir del código
  intltool-extract --type=gettext/glade gtkfilesplitter.glade
  xgettext -k_ -kN_ -o locale/messages.pot *.py *.h
  for lang in $(PO); \
    do msgmerge -U locale/$$lang.po locale/gtkfilesplitter.pot; \
  done

]]></programlisting>

  Lo fundamental es entender las tareas que realiza el target <command>install</command>: los
  directorios en que se copian los archivos, etc.
  </para>

  <para>
  Debido la complejidad que supone crear uno de estos archivos y a que muchas de estas tareas
  se repiten de forma bastante rutinaria, se creó un proyecto llamado el 
  <ulink url="https://perso.duckcorp.org/duck/cdbs-doc/cdbs-doc.xhtml">Common Debian Build
  System</ulink>, que consiste en un conjunto de Makefiles ya creados para un conjunto de proyectos
  diferentes, de forma que bastaría con incluir estas recetas en tus archivos 
  <filename>debian/rules</filename> para hacerlos de forma mucho más sencilla. Lamentablemente
  la documentación sobre CDBS es bastante escasa, pero la idea es que para un proyecto Python con
  una convención de directorios estándar, el archivo podría quedar tan sencillo como:

<programlisting><![CDATA[#!/usr/bin/make -f
include /usr/share/cdbs/1/rules/debhelper.mk
include /usr/share/cdbs/1/class/python-distutils.mk
]]></programlisting>

  De hecho, pude empaquetar con muy poco código una aplicación desarrollada en Java y compilada
  con Ant, como se verá en la siguiente sección.
  </para>

  </sect3>


  <sect3>
  <title>Construir el paquete con dpkg-buildpackage</title>

  <para>
  Para producir el paquete firmado, necesitamos el identificador corto de la firma digital (en el ejemplo
  en el punto anterior, era <filename>BB7576AC</filename>). Para producir el paquete firmado ejecutamos
  el siguiente comando:

  <programlisting><![CDATA[$ dpkg-buildpackage -sgpg -kBB7576AC -rfakeroot ]]></programlisting>
  </para>

  <para>
  Las opciones utilizadas son <filename>-sgpg</filename> para utilizar firma GnuPG. La opción
  <filename>-k</filename> es el identificador de la llave a utilizar. Para crear los paquetes se
  requiere utilizar un pseudoambiente de root, para lo que se usa la herramienta
  <filename>fakeroot</filename>.
  </para>

  <para>
  El proceso para generar el archivo de paquetes puede demorar un poco y se escribe una gran
  cantidad de texto en pantalla a medida que se ejecuta un gran conjunto de tareas. Finalmente,
  si no hay errores en la construcción, se nos pedirá la contraseña utilizada al crear nuestras
  llaves GnuPG para poder firmar unos archivos que forman parte del paquete.
  </para>

  <para>
  Felicitaciones! En este momento deberías contar con tu programa empaquetado apropiadamente
  como un archivo Deb.
  </para>
  </sect3>

  <sect3>
          <title>Validación de paquetes con Lintian y Linda</title>
          <para>
                  Luego de tanto esfuerzo, es posible que hayamos omitido algún paso,
                  u omitido alguna información que venía por completar en alguna plantilla
                  de documentos, o en general, errores menores o no conformidad con las
                  políticas y convenciones de Debian para la instalación de Software
                  (existen restricciones a donde se pueden colocar archivos, bibliotecas
                  y con qué permisos, además de las políticas para Python y Java).
          </para>

          <para>
          Para revisar la conformidad de nuestros paquetes de software con estas 
          restricciones y convenciones, existe un par de programas, llamados
          <command>lintian</command> y <command>linda</command> que realizan estas
          tareas y reportan advertencias y errores que contienen nuestros paquetes.

          <programlisting><![CDATA[$ lintian gtkfilesplitter_0.1.3-0ubuntu3_i386.deb
W: gtkfilesplitter: binary-without-manpage usr/bin/gtkfilesplitter
W: gtkfilesplitter: package-contains-empty-directory usr/share/pixmaps
W: gtkfilesplitter: package-contains-empty-directory usr/share/gnome/help/gtkfilesplitter/C
...
E: gtkfilesplitter: debian-changelog-file-contains-invalid-address denis@laptop
...
]]></programlisting>

          En este caso, las advertencias son: El paquete no contiene página de manual,
          el paquete contiene directorios vacíos. El error es que en las entradas
          del archivo de ChangeLog aparecen direcciones de correo no válidas.</para> 
  </sect3>

  </sect2>

  <sect2>
    <title>Creación de un paquete Debian con Java, Ant y CDBS</title>

  <para>
    Durante varios años, Java era una alternativa atractiva (sobretodo a nivel de empresa)
    para desarrollo de aplicaciones, pero no había atraido de manera importante la
    atención de los desarrolladores de aplicaciones de escritorio. Al momento de escribir
    estas líneas, me parece que esto va a cambiar de forma significativa.
  </para>

  <para>
    Java se está convirtiendo rápidamente en una plataforma Open Source. Sun Microsystems
    ya ha liberado la mayor parte del código fuente de la máquina virtual y de las
    bibliotecas de clases mediante el proyecto OpenJDK, de forma que está a la par con
    otras alternativas que deberían ser más o menos equivalentes, como el proyecto Mono.
  </para>

  <para>
    De hecho, si bien existen paquetes que permiten instalar Java en Ubuntu (
    <filename>sun-java5</filename> y <filename>sun-java6</filename>), estos
    requieren aprobar una licencia por separado en el momento de instalarse.
    Hoy ya existe una implementación basada sólo en Software Libre (en el paquete
    <filename>icedtea-java7</filename>).
  </para>

  <para>
    Si bien existen diferentes alternativas de ambientes de desarrollo libres
    para programar en Java (Eclipse y Netbeans, por ejemplo, cada una con sus
    partidarios y detractores), algo que se ha establecido como un estándar de
    facto es el uso de la herramienta Ant para la construcción de proyectos Java.
  </para>

  <para>
    Ant partió como un reemplazo de GNU Make, porque al autor le parecía que la
    sintaxis de los Makefiles era horrible y era muy fácil caer en errores 
    difíciles de detectar, como reemplazar tabuladores por espacios en un Makefile.
    En su lugar, Ant utiliza un archivo XML (<filename>build.xml</filename>) donde
    se establecen diferentes objetivos (targets) para un proyecto: desde limpiar los
    archivos de una compilación o respaldo anterior, hasta compilarlo, generar un
    una biblioteca Jar y una enorme cantidad de tareas que se han agregado con el tiempo.
  </para>

  <para>
    Finalmente Ant se ganó el corazón de los equipos que deseaban una forma de
    construir sus proyectos Java de forma independiente de la herramienta de
    desarrollo y plataforma, y así Ant llega a tener soporte incluso en Eclipse y Netbeans.
  </para>

  <para>
    Empaquetar software ya desarrollado en Java y Ant es bastante sencillo como veremos.
    En primer lugar, una aplicación Java como la mencionada suele tener su código fuente
    contenido en una carpeta (<filename>source</filename> o <filename>src</filename>
    o similar) y un archivo <filename>build.xml</filename> en la raíz del proyecto.
   
    Para construir el proyecto, debería bastar con tener instalado Ant y un kit de desarrollo
    Java (JDK) y simplemente ejecutar en la línea de comandos:

    <programlisting><![CDATA[$ ant ]]></programlisting>

    Dependiendo de la naturaleza del proyecto pueden ejecutarse varios pasos aparte de la
    simple compilación del código fuente: es posible que se ejecuten pruebas unitarias
    creadas con JUnit o algún tipo de generación de código, JavaDocs o similares.
  </para>

  <para>
   Para comenzar a Debianizar este proyecto Java, ejecutamos:
   <programlisting><![CDATA[$ dh_make -c gpl -e usuario@miempresa.com -s --createorig ]]></programlisting>
  </para>

  <sect3>
    <title>Archivo <filename>debian/control</filename> de un paquete creado con Java</title>

    <para>
      En el caso de que nuestro paquete de software dependa de una versión
      específica de la plataforma Java (ej. si utiliza "Generics" se requiere
      al menos de un entorno de Java 5) o de otras bibliotecas desarrolladas
      con Java (ej. Jakarta Commons), se deberá especificar en el archivo
      <filename>debian/control</filename> de forma precisa en las líneas
      <command>Build-Depends</command> y <command>Depends</command>.
      En el caso de los entornos de ejecución (JRE) existen paquetes virtuales
      que permiten que espefiques una versión de Java sin necesidad de
      limitarlo a una implementación en particular (ej. es mejor usar
      <filename>java5-runtime</filename> en lugar de
      <filename>sun-java5-jre</filename>).
    </para>

    <para>
      Afortunadamente, ya hay muchas bibliotecas Java empaquetadas en Debian
      y Ubuntu, todas tienen un nombre de paquete con la convención
      <filename>libXXXX-java</filename>
      (ej. <filename>libcommons-httpclient-java</filename>) y la política
      para paquetes de software Java indica que todos los archivos 
      de bibliotecas Jar quedarán instalados en
      <filename>/usr/share/java/</filename>.
    </para>

  </sect3>

  <sect3>
    <title>Archivo <filename>debian/rules</filename> de un paquete creado con Java</title>

    <para>
      Esto es algo realmente afortunado. Los archivos <filename>debian/rules</filename> de este
      tipo de paquetes pueden quedar realmente sencillos con ayuda de CDBS, como veremos en
      el ejemplo, un paquete hecho de un software llamado <command>Privatewiki</command>
      (es una aplicación que escribí hace tiempo, la idea es más o menos similar a Tomboy).
    </para>

    <para>
      El archivo es el siguiente:

      <programlisting><![CDATA[#!/usr/bin/make -f

include /usr/share/cdbs/1/rules/debhelper.mk
include /usr/share/cdbs/1/class/ant.mk

# Estoy usando esta versión sólo para empaquetar!
JAVA_HOME := /usr/lib/jvm/java-1.5.0-sun
ANT_HOME := /usr/share/ant

install/privatewiki:: DEB_FINALDIR=$(CURDIR)/debian/privatewiki
install/privatewiki::

  # Creo varios directorios
  install -d $(DEB_FINALDIR)/usr/bin
  install -d $(DEB_FINALDIR)/usr/share/privatewiki
  install -d $(DEB_FINALDIR)/usr/share/java
  install -d $(DEB_FINALDIR)/usr/share/pixmaps
  install -d $(DEB_FINALDIR)/usr/share/applications

  # Instalo un shell que sirve para lanzar mi programa
  install -m 755 $(CURDIR)/debian/bin/privatewiki \
    $(DEB_FINALDIR)/usr/bin/

  # Un archivo con datos usados por mi programa, iconos, etc.
  install -m 755 $(CURDIR)/bin/data.zip \
    $(DEB_FINALDIR)/usr/share/privatewiki/data.zip
  install -m 755 $(CURDIR)/resources/icons/private.png \
    $(DEB_FINALDIR)/usr/share/pixmaps/privatewiki.png
  install -m 755 $(CURDIR)/debian/bin/privatewiki.desktop \
    $(DEB_FINALDIR)/usr/share/applications/privatewiki.desktop
  install -m 644 $(CURDIR)/lib/privatewiki.jar \
    $(DEB_FINALDIR)/usr/share/java/privatewiki.jar
]]></programlisting>

    Sí, eso es todo. El truco es la línea donde se incluye el archivo <filename>ant.mk</filename>
    lo que da instrucciones para realizar ciertas tareas con Ant y el archivo 
    <filename>build.xml</filename> que debería tener mi proyecto Java.
    </para>

    <para>
      El archivo <filename>build.xml</filename> de la raíz de mi proyecto es el siguiente:

      <programlisting><![CDATA[<?xml version="1.0"?>
<project name="privatewiki" default="jar">

   <property name="src" value="src"/>

   <!-- limpiar proyecto -->
   <target name="clean">
       <delete failonerror="false">
           <fileset dir="lib" includes="**.jar" />
       </delete>
       <delete dir="lib"  failonerror="false" />
       <delete dir="classes"  failonerror="false" />
   </target>

   <!-- compilar clases Java -->
   <target name="compile">
     <mkdir dir="classes" />
     <javac srcdir="src" destdir="classes" />
   </target>

   <!-- crear archivo Jar, requiere limpiar y compilar -->
   <target name="jar" depends="clean,compile">
     <mkdir dir="lib" />
     <jar jarfile="lib/privatewiki.jar"
        basedir="classes"
        compress="true"
        >
         <fileset dir="classes" />
         <fileset dir="resources" />

         <!-- indico la clase que inicia la ejecucion -->
         <manifest>
             <attribute name='Main-Class' value='privatewiki.Main'/>
         </manifest>
      </jar>
    </target>

</project>]]></programlisting>

      Lo importante es que construcción del proyecto con Ant realice todas las
      tareas necesarias para tener una aplicación lista para ejecutar. El 
      archivo <filename>debian/rules</filename> toma el resto de los artefactos
      para producir el paquete y listo.
    </para>

    <para>
     Finalmente, el documento de Java Policy en Debian indica que no se puede
     depender de un valor determinado para la variable de ambiente CLASSPATH
     (que se utiliza para indicar la ruta de búsqueda de bibliotecas Java para
     un programa en ejecución). Para modificar el CLASSPATH para los requerimientos
     de un programa, lo adecuado es crear un shell script que haga las modificaciones
     necesarias para el entorno de nuestro programa y luego invoque el programa
     en cuestion, por ejemplo:

     <programlisting><![CDATA[#!/bin/sh

  # CLASSPATH
  export CLASSPATH=/usr/share/java/xxx1.jar:/usr/share/java/yyy2.jar

  # Ejecuto mi programa
  java org.miproyecto.MiApplicacion -Dflag1=valor -Dflag2=valor
]]></programlisting>

    En mi proyecto <command>privatewiki</command>, uso un script para
    detectar un archivo de datos (con las notas que llena el usuario en
    su wiki personal) y ejecuto el programa en un directorio determinado:

     <programlisting><![CDATA[#!/bin/sh

set -e

# Test if ${HOME}/.privatewiki exists
DATADIR="$HOME"/.privatewiki

if [ -d $DATADIR ]; then
    echo "data dir found"
else
    mkdir ${HOME}/.privatewiki
fi

# Test if ${HOME}/.privatewiki/data.zip exists
DATAFILE="$HOME"/.privatewiki/data.zip

if [ -e $DATAFILE ]; then
        echo "datafile ok"
else
        echo "no datafile"
	cp /usr/share/privatewiki/data.zip ${HOME}/.privatewiki/data.zip
fi

cd "$HOME"/.privatewiki
java -jar /usr/share/java/privatewiki.jar
]]></programlisting>

    Para terminar, el código fuente completo y debianizado de <command>privatewiki</command>
    está disponible en
    <ulink>http://desarrollo-ubuntu.googlecode.com/svn/trunk/privatewiki-0.1/</ulink>

    </para>

  </sect3>

  </sect2>

  </sect1>

  <sect1>
  <title>Creación de un repositorio sencillo</title>

  <para>
  Un repositorio consiste en una estructura de carpetas publicadas en un servidor web
  con una estructura y contenidos tales que se pueden obtener paquetes y actualizaciones
  de software periodicas, integradas con nuestro sistema Ubuntu o Debian.
  </para>

  <para>
  Un repositorio Debian utiliza una estructura de directorios para colocar paquetes Debian
  (archivos <filename>.deb</filename>) y añade ciertos archivos extras con información sobre
  los paquetes que se encuentran disponibles.
  </para>

  <para>
  Prar crear el repositorio, se debe crear una estructura de directorios (en este ejemplo,
  es para Ubuntu 7.10, "Gutsy Gibbon") en la raíz de un directorio publicado en un servidor
  web (puede ser Apache, pero generalmente yo uso <command>lighttpd</command> que es mucho más
  sencillo de configurar para pruebas). También estoy asumiendo que los paquetes de software
  son para arquitectura i386 (procesadores compatibles con Intel x86). Otras arquitecturas
  válidas que puedes ver son <filename>amd64</filename>, <filename>powerpc</filename> y
  <filename>sparc</filename>.

<programlisting><![CDATA[$ mkdir dists
$ mkdir dists/gutsy
$ mkdir dists/gutsy/main
$ mkdir dists/gutsy/main/binary-i386 ]]></programlisting>

  Copiamos los archivos Deb (que queremos colocar en el repostorio) al directorio de destino:

<programlisting><![CDATA[$ cp /tmp/source/*.deb dists/gutsy/main/binary-i386 ]]></programlisting>

  Creamos los archivos de descripción de los paquetes (llamado <filename>Packages</filename>)
  y lo comprimimos:

<programlisting><![CDATA[$ apt-ftparchive packages dists/gutsy/main/binary-i386/ \
  > dists/gutsy/main/binary-i386/Packages
$ cat dists/gutsy/main/binary-i386/Packages | gzip -9c \
  > dists/gutsy/main/binary-i386/Packages.gz ]]></programlisting>

  Creamos un archivo de descripción de nuestro repositorio, llamado <filename>apt.conf</filename>.
  Aqui reproduzco el que utilizan los desarrolladores de Automatix:

<programlisting><![CDATA[APT::FTPArchive::Release::Origin "automatix";
APT::FTPArchive::Release::Label "automatix updates";
APT::FTPArchive::Release::Suite "stable";
APT::FTPArchive::Release::Codename "gutsy";
APT::FTPArchive::Release::Architectures "i386 source";
APT::FTPArchive::Release::Components "main testing";
APT::FTPArchive::Release::Description "This repository contains ..."; ]]></programlisting>

  con lo cual creamos un archivo de <filename>Release</filename>. Este archivo permite agregar
  más metadatos sobre el propósito del repositorio, las arquitecturas soportadas y la versión de
  Ubuntu o Debian para la cual queremos crear el repositorio.

<programlisting><![CDATA[$ apt-ftparchive -c apt.conf release dists/gutsy/ \
  > dists/gutsy/Release
]]></programlisting>

  Finalmente, utilizamos firma digital sobre este archivo de Release. Esto permitirá que,
  si hemos agregado la llave pública a nuestro depósito de firmas, el actualizador de paquetes
  valide las firmas digitales de forma automática y sin alertas de seguridad para nuestros usuarios.

  <programlisting><![CDATA[$ gpg --output dists/gutsy/Release.gpg -ba dists/gutsy/Release ]]></programlisting>

  Con esto, nuestro software queda disponible para que los usuarios agreguen la dirección web
  en la que hemos colocado el repositorio a su archivo <filename>/etc/apt/sources.list</filename> o
  mediante el menú <command> Sistema - Administración - Orígenes de Software - Software de Otros
  Proveedores - Agregar</command>
  y puedan instalar los paquetes de software del repositorio usando <command>apt-get install</command>
  o <command>synaptic</command>, etc.
  </para>

  <para>
  Si la carpeta raíz (donde hemos creado las carpetas <filename>dists</filename>) y las otras están
  visibles en la dirección web <filename>http://127.0.0.1/ubuntu</filename>, entonces esta dirección
  web será la dirección que deberás utilizar para la linea de APT de tu repositorio.
  </para>

  <para>
  Una linea de APT tiene la siguiente apariencia:

<programlisting><![CDATA[deb http://www.servidor.com/ruta/ release componente1 componente2 ...]]></programlisting>

  donde <command>release</command> es la versión de Ubuntu o Debian para que estamos creando el repositorio
  (en el ejemplo anterior, era <filename>gutsy</filename>). Los componentes 1, 2, etc., son los diferentes
  componentes del repositorio de acuerdo a si son software libre parte de la distribución oficial
  (<command>main</command>) o son software con una licencia no libre (<command>restricted</command>),
  software libre no mantenido por Ubuntu (<command>universe</command>) o software ni libre ni mantenido por Ubuntu
 (<command>multiverse</command>). Generalmente nuestros repositorios caerán en una de las 2 últimas categorías,
  por lo que nuestros repositorios tendrán una línea de Apt como la siguiente:

  <programlisting><![CDATA[deb http://www.miservidor.com/ubuntu/ gutsy universe]]></programlisting>
  </para>

  <para>
  NOTA: En el ejemplo de estructura de directorios anterior hemos usado el componente <filename>main</filename>
  para colocar nuestros paquetes de software, por lo que la línea de APT correcta será

  <programlisting><![CDATA[deb http://www.miservidor.com/ubuntu/ gutsy main]]></programlisting>

  </para>

  <para>
  Esta es una receta para crear un repositorio de forma más o menos sencilla. Existen otras maneras
  que permiten optimizar espacio en disco cuando existen paquetes binarios con el mismo contenido,
  y varios releases y arquitecturas distintas en un mismo servidor y repositorio. La fuente oficial
  de documentación para estos casos es el
  <ulink url="www.debian.org/doc/manuals/repository-howto/repository-howto">Debian Repository HOWTO</ulink>
  </para>

  <sect2>
  <title>Soporte para Internacionalización en los repositorios</title>

  <para>
  Ubuntu posee un amplio soporte para hacer que el sistema sea más accesible para usuarios muchos
  idiomas y eso incluye la capacidad para usar descripciones de los paquetes de software instalables
  en diferentes idiomas. La especificación del soporte para descripciones multilenguaje en los
  repositorios se encuentra en el documento
  <ulink url="https://wiki.ubuntu.com/TranslatedPackageDescriptionsSpec">Translated Package
  Descriptions Spec</ulink>.
  </para>

  <para>
  Para utilizar traducciones de los paquetes de software, es necesario crear un directorio en el 
  repositorio que contenga los archivos con las traducciones de la información de paquetes:

  <programlisting><![CDATA[$ mkdir dists/gutsy/main/i18n ]]></programlisting>
  </para>

  <para>
  En este directorio se colocan diferentes archivos comprimidos que siguen la siguiente convención
  de nombres: <filename>Translation-XX.bz2</filename> donde <filename>XX</filename> es el código
  ISO de 2 letras que identifica el idioma. En el caso de las traducciones al español, será el archivo
  comprimido <filename>Translation-es.bz2</filename>
  </para>

  <para>
  El contenido del archivo será un conjunto de entradas que contienen un campo 
  <filename>Package:</filename>, un campo con la suma MD5 de la descripción original del paquete
  en la versión en inglés (<filename>Description-md5:</filename>) y la descripción en el idioma
  de la traducción (<filename>Description-es:</filename> para la versión en español).
  </para>

  <para>
  Para la traducción de mi repositorio en el que tengo el paquete <filename>gtkfilesplitter</filename>,
  el contenido del archivo <filename>dists/gutsy/main/i18n/Translation-es</filename> es
  la siguiente:

  <programlisting><![CDATA[Package: gtkfilesplitter
Description-md5: bc3667f71f65f0ffa387067d48c2a620
Description-es: Aplicación sencilla que troza y junta archivos con comprobación
 Una aplicación de escritorio para dividir archivos en trozos y volver a
 unirlos.
 .
 Para más información, visite http://code.google.com/p/gtkfilesplitter/
]]></programlisting>

  ... luego un salto de línea, y se repite para tantos paquetes como tengamos
  en el repositorio.
  </para>

  <para>
  Unos detalles adicionales para calcular la suma MD5 que se requiere colocar: La forma más
  sencilla de realizar el cálculo es crear un archivo temporal y colocar la descripción completa
  del paquete de software como viene en el archivo
  <filename>dists/gutsy/main/binary-i386/Packages</filename>, sin incluir el comienzo de la línea
  "<filename>Description: </filename>" (espacio luego de los dos puntos inclusive) de modo que quede así:

  <programlisting><![CDATA[$ cat /tmp/descripcion.txt
Simple file splitter/joiner with checksum support
 A desktop application to split and join files
 .
 For more information, visit http://code.google.com/p/gtkfilesplitter
]]></programlisting>

  </para>

  <para>
  Para calcular la suma MD5 que necesitamos para la traducción, basta con usar:

  <programlisting><![CDATA[$ md5sum /tmp/descripcion.txt
bc3667f71f65f0ffa387067d48c2a620 */tmp/descripcion.txt ]]></programlisting>

  y copiamos el valor de la suma MD5 en el campo que corresponde en nuestro archivo con
  traducciones. Finalmente, el archivo debe ir comprimido con <command>bzip2</command> de
  la siguiente forma:

  <programlisting><![CDATA[$ bzip2 dists/gutsy/main/i18n/Translation-es ]]></programlisting>

  De esta manera, las traducciones aparecen al actualizar la información de las actualizaciones
  posibles en el Gestor de Actualizaciones (Update Manager):
  </para>

  <para>
  <inlinemediaobject>
    <imageobject><imagedata fileref="img/gestor-actualizaciones1.png" format="PNG" 
     width="6in" /></imageobject>
    <textobject><phrase>Traducciones al español en las actualizaciones de software</phrase></textobject>
  </inlinemediaobject>
  </para>

  <para>
  Finalmente, la lista de cambios que debería aparecer en la lengueta <command>Cambios</command>
  sólo aparece para paquetes que se encuentren oficialmente en la distribución. Revisé el
  código y en el caso de Ubuntu, el listado de cambios se descarga desde el servidor
  <filename>changelogs.ubuntu.com</filename> siguiendo una convención de directorios, que en caso
  de un paquete como <filename>abiword</filename> sería 
  <filename>http://changelogs.ubuntu.com/changelogs/pool/main/a/abiword/abiword_2.4.6-3ubuntu2/changelog</filename>. En el caso de Debian, el listado de cambios se obtiene desde su propio servidor, y en el ejemplo
  anterior, la dirección es
  <filename>http://changelogs.debian.net/abiword</filename>
  </para>

  </sect2>
  </sect1>


</chapter>

