<?xml version="1.0" encoding="ISO-8859-1" ?>
<!-- $Id$ -->

<chapter>
  <title>Empaquetado y distribución de software para Ubuntu</title>

  <para>
  Hemos llegado al punto en que tenemos software con una calidad y robustez suficiente
  como para comenzar a distribuirlo con nuestros usuarios. En este capítulo revisaremos
  el proceso de empaquetar un proyecto de software como un paquete instalable en un
  sistema y de como este paquete se puede colocar en un repositorio de software de forma
  que los usuarios de nuestra aplicación puedan obtener de forma automática las nuevas
  versiones mejoradas y ampliadas de nuestro software ya publicado.
  </para>

  <sect1>
  <title>Entendiendo los paquetes de software</title>
  <para>
  En sistemas basados en Debian (como Ubuntu, Knoppix y otros) el software que se
  instala en nuestros equipos se encuentra agrupado lógicamente en paquetes, que se
  obtienen desde los discos de instalación e Internet. Estos paquetes contienen los
  archivos que se instalan en nuestros sistemas, más cierta información de contexto
  (metadatos) que indican que cada uno de estos componentes de software obedece ciertas
  reglas y cuales son los recursos de los que provee a nuestro sistema.
  </para>

  <para>
  En general, entonces, diremos que un paquete de software es un elemento que se compone
  de un conjunto de archivos a instalar, y que posee información sobre su versión, los
  otros paquetes de software que requiere para funcionar, los recursos que este paquete
  provee para nuestro sistema y eventualmente, con cuales componentes no se lleva bien 
  (porque puede haber incompatibilidades entre 2 componentes diferentes).
  </para>

  <sect2>
  <!-- versiones del software -->
  <title>Versiones de un elemento de software</title>
  <para>
  Los paquetes de software que instalamos y producimos poseen un número de versión que
  sirve para identificar un conjunto de características que ese software posee, en
  términos de funcionalidades, errores corregidos y por corregir, entre otros. Hay una regla
  más o menos genérica que indica que se usa un número mayor de versión para indicar 
  grandes hitos en el desarrollo de un programa, luego un número menor de versión para
  indicar el grado de avance en el desarrollo de funcionalidades entre estos grandes hitos,
  y finalmente, un tercer número que indica correcciones de seguridad hechas a un programa.
  </para>

  <para>
  De esta forma, un programa en la versión <filename>1.5.3</filename> indica que ya se
  alcanzó el primer gran
  hito de desarrollo del programa (<command>1</command>), en camino hacia una versión
  2. El número de versión menor <command>5</command> indica que es la quinta entrega
  de funcionalidades (desde la versión 1.0), y además
  el tercer dígito de versión (<command>3</command>) indica que se han hecho 3
  correcciones importantes de seguridad a la versión 1.5 de este programa.
  </para> 
  </sect2>

  <sect2>
  <!-- dependencias -->
  <title>Dependencias de un elemento de software</title>

  <para>
  En general, el software de nuestros equipos funciona sobre una cantidad bastante de
  otros componentes previamente instalados, de la misma forma en que el techo de una casa
  descansa sobre las murallas, que a su vez, descansan en los cimientos. Así, nuestro
  software funcionará sobre la base de que otros componentes de software ya se encuentren
  instalados.
  </para>
  </sect2>


  </sect1>

  <!-- Creando un paquete de software Debian -->
  <sect1>
  <title>Creación de un paquete de software Debian</title>

  <para>
  Al ser una distribución basada en Debian, la creación de paquetes en Ubuntu utiliza
  el mismo conjunto de herramientas de ayuda para el proceso de empaquetamiento, entre
  las que se encuentran <filename>dh_make</filename>, <filename>dch</filename>,
  <filename>fakeroot</filename> y otros.
  </para>

  <para>
  A diferencia de otros textos publicados en Internet, vamos a cubrir el escenario más
  completo posible, lo que implica que vamos a crear paquetes fuente y binarios que
  utilizarán un esquema de firma digital basada en GNU Privacy Guard (que es una
  implementación libre del
  estándar de firma digital PGP), para que los usuarios de los paquetes que empaquetemos
  puedan obtener las versiones más recientes del software sin advertencias que puedan
  intimidarlos. Si no usamos firmas en el software que empaquetamos y en los repositorios
  de software a crear, el sistema indica una serie de advertencias al usuario (sobre
  el riesgo de instalar software que no ha sido firmado por ningún responsable) que
  pueden despertar suspicacias o rechazo, cada vez que publiquemos una nueva actualización
  de nuestro software.
  </para>

  <sect2>
  <title>Creación de una firma digital con GnuPG</title>

  <para>
  En primer lugar, se requiere instalar y configurar el software requerido para firmar
  digitalmente los archivos. Las herramientas para empaquetamiento y distribución de
  software en Debian y Ubuntu se encuentran bien integradas con GnuPG y es sencillo de
  utilizar.
  </para>

  <para>
 Procedemos a instalar GnuPG:

  <programlisting><![CDATA[$ sudo apt-get install gnupg ]]></programlisting>

  Una buena guía sobre la instalación de GnuPG se encuentra en la siguiente dirección:
  <ulink url="http://www.gnupg.org/(en)/documentation/howtos.html">http://www.gnupg.org/(en)/documentation/howtos.html</ulink>

  </para>


  <!-- TODO: Agregar referencia al HOWTO en http://www.gnupg.org/(en)/documentation/howtos.html -->

  <para>
  Luego de instalado, debemos generar un conjunto de llaves pública y privada con las
  que funciona el mecanismo de firma digital. Para ello, ejecutamos en un terminal:
  <programlisting><![CDATA[$ gpg --gen-key ]]></programlisting>
  </para>

  <para>
  El programa nos preguntará primero sobre el algoritmo a utilizar para la generación de las claves,
  para lo cual dejamos el algoritmo sugerido por omisión. La siguiente pregunta es la longitud de la
  clave, para lo cual también dejamos al largo sugerido. Luego se nos pregunta el tiempo durante el
  cual estas claves serán vigentes. Para efectos prácticos, 6 meses o un año pueden estar bien,
  pero es posible que otras organizaciones o proyectos usen períodos diferentes por motivos de
  seguridad.
  Luego, el programa pide algunos datos del
  usuario para registrar la identificación de quien firma: El nombre, un comentario o alias y una
  dirección de correo electrónico.
  </para>

  <para>
  Finalmente, se pide una contraseña que se utiliza cada vez que se va a firmar. La contraseña
  idealmente debe ser larga, que combine mayúsculas y minúsculas, etc.
  </para>

  <para>
  A continuación, el programa realiza un trabajo que puede demorar algunos momentos y que consiste
  en la generación de la llave pública y privada, que se basa en la generación de números primos
  mediante la recolección de datos más o menos aleatorios como la fecha y hora, carga del procesador,
  memoria utilizada y un largo etcétera. Puede demorar un poco. Para comprobar la firma recien generada,
  se pueden listar las claves junto a un identificador corto que le corresponde a cada una, con el
  siguiente comando:

<programlisting><![CDATA[$ gpg --list-keys
/users/alice/.gnupg/pubring.gpg
---------------------------------------
pub  1024D/BB7576AC 1999-06-04 Alice (Judge) <alice@cyb.org>
sub  1024g/78E9A8FA 1999-06-04
]]></programlisting></para>

  <para>
  Este comando produce un listado, del cual nos interesa el identificador hexadecimal junto
  a la llave pública. En el listado anterior, es el código <filename>BB7576AC</filename>. Conviene
  tener este identifiador a mano a la hora de firmar paquetes y hacer cambios en el repositorio
  que vamos a crear.
  </para>

  <para>
  Un programa que hace todas estas tareas más sencillas, con una interfaz gráfica, es
  <ulink url="http://www.gnome.org/projects/seahorse/">Seahorse</ulink>, y que puede
  verse en la siguiente captura de pantalla.
  </para>

  <para>
  <inlinemediaobject>
    <imageobject><imagedata fileref="img/seahorse1.png" format="PNG" width="6in" /></imageobject>
    <textobject><phrase>Pantalla del programa SeaHorse</phrase></textobject>
  </inlinemediaobject>
  </para>

  <para>Seahorse queda instalado en <command>Aplicaciones - Accesorios - Contraseñas y claves de cifrado</command></para>

  </sect2>

  <sect2>
  <title>Agregar la llave pública a tus proveedores de software de confianza</title>

  <para>
  Para probar la firma digital sobre los paquetes se software que desarrolles, deberás
  agregar tu llave pública al listado de proveedores de software a los que tienes
  confianza. De lo contrario, cada vez que instales software producido por tí, aparecerán
  advertencias indicando que sólo debes instalar programas que vienen de fuentes de confianza.
  </para>

  <para>
  Lo que debes hacer es agregar el archivo con tu llave pública (<filename>pubring.gpg</filename>)
  a la aplicación que se encuentra en <command>Sistema - Administración - 
  Orígenes del Software</command>. En la lengueta <command>Autentificación</command> encontrarás
  el listado de firmas digitales que tu sistema acepta para validar paquetes de software firmados.
  Para agregar tu llave pública, usa el botón <command>Importar Clave</command> para importar el
  archivo <filename>/home/USUARIO/.gnupg/pubring.gpg</filename>. Tu firma debería aparecer en el
  listado, como en la siguiente pantalla:
  </para>

  <para>
  <inlinemediaobject>
    <imageobject><imagedata fileref="img/origenes-del-software1.png" format="PNG" 
     width="6in" /></imageobject>
    <textobject><phrase>Listado de claves GPG de confianza en los orígenes del software</phrase></textobject>
  </inlinemediaobject>
  </para>

  </sect2>

  <sect2>
  <title>Creación de un paquete Debian</title>

  <para>
  Para crear un paquete Debian, el proceso consta de copiar el código fuente de nuestro proyecto
  y agregar unos archivos de datos extras utilizados por las herramientas que forman los paquetes.
  Cuando el código se obtiene desde un tarball o desde un repositorio de código fuente, este proceso
  de agregar archivos de Debian se llama "Debianización".
  </para>

  <para>
  Procederemos a instalar los siguientes paquetes para instalar las utilidades mínimas para construir
  paquetes Debian:

  <programlisting><![CDATA[$ sudo apt-get install dh-make devscripts fakeroot ]]></programlisting>

  (en caso de construir programas a partir de código fuente en C, también se requiere
  instalar el paquete <filename>build-essential</filename>):
  </para>

  <para>
  Para producir el paquete, obtenemos una copia del código fuente de nuestro proyecto en un directorio
  temporal (por ejemplo, <filename>/tmp/debianizando/gtkfilesplitter-0.2</filename>). El directorio debe
  seguir la siguiente convención: [nombre-del-proyecto]-[versión]. En el ejemplo, el nombre del proyecto
  es <filename>gtkfilesplitter</filename> y la versión es la 0.2.
  </para>

  <para>
  En el directorio donde se encuentra el código fuente de nuestro proyecto, ejecutamos

  <programlisting><![CDATA[$ dh_make -c gpl -e usuario@miempresa.com -s --createorig ]]></programlisting>
  </para>

  <para>
  La herramienta <filename>dh_make</filename> agregará los archivos con la información extra para
  producir el paquete en un directorio <filename>debian</filename> en el directorio actual. El
  parámetro <filename>-c</filename> indica el tipo de licencia a utilizar (las opciones con GPL, LGPL,
  entre otras). La dirección de correo del usuario que produce el paquete se especifica con la
  opción <filename>-e</filename>. Para firmar el paquete hemos utilizado la opción <filename>-s</filename>
  (por "sign") y finalmente, es posible que no hayamos generado el directorio con el código fuente
  a partir de un tarball, así que la opción <filename>--createorig</filename> le indica al programa
  que la genere por nosotros.
  </para>

  <para>
  <!-- TODO mejorar descripción de los archivos luego de dh_make -->
  La ejecución del programa deja tras de sí un directorio <filename>debian</filename> con un conjunto
  de archivos con información del paquete que deberíamos modificar, y en el directorio superior, un
  archivo comprimido (con tar y gzip) con el contenido del directorio antes de la Debianización, un
  archivo de cambios y un archivo extra.
  </para>

  <para>
  Si es necesario indicar que este paquete tiene algunas correcciones producto de una mejora o debido
  a que se aplicó algún parche, se puede indicar en un archivo de ChangeLog. Existe un utilitario que
  sirve para esto:

  <programlisting><![CDATA[$ dch -i ]]></programlisting>
  </para>

  <para>
  Este programa abrirá el archivo <filename>debian/changelog</filename> del proyecto y agregará unas
  lineas de contexto para poder agregar la lista de cambios de esta versión de nuestro programa.
  Guardamos los cambios al archivo, salimos del editor y estamos listos para producir el paquete Debian.
  </para>

  <para>
  Para producir el paquete firmado, necesitamos el identificador corto de la firma digital (en el ejemplo
  en el punto anterior, era <filename>BB7576AC</filename>). Para producir el paquete firmado ejecutamos
  el siguiente comando:

  <programlisting><![CDATA[$ dpkg-buildpackage -sgpg -kBB7576AC -rfakeroot ]]></programlisting>
  </para>

  <para>
  <!-- TODO verificar el uso de fakeroot -->
  Las opciones utilizadas son <filename>-sgpg</filename> para utilizar firma GnuPG. La opción
  <filename>-k</filename> es el identificador de la llave a utilizar. Para crear los paquetes se
  requiere utilizar un pseudoambiente de root, para lo que se usa la herramienta
  <filename>fakeroot</filename>.
  </para>

  <para>
  El proceso para generar el archivo de paquetes puede demorar un poco y se escribe una gran
  cantidad de texto en pantalla a medida que se ejecuta un gran conjunto de tareas. Finalmente,
  si no hay errores en la construcción, se nos pedirá la contraseña utilizada al crear nuestras
  llaves GnuPG para poder firmar unos archivos que forman parte del paquete.
  </para>

  <para>
  Felicitaciones! En este momento deberías contar con tu programa empaquetado apropiadamente
  como un archivo Deb.
  </para>

  </sect2>
  </sect1>

  <sect1>
  <title>Creación de un repositorio</title>

  <para>
  Un repositorio consiste en una estructura de carpetas publicadas en un servidor web
  con una estructura y contenidos tales que se pueden obtener paquetes y actualizaciones
  de software periodicas, integradas con nuestro sistema Ubuntu o Debian.
  </para>

  <para>
  Un repositorio Debian utiliza una estructura de directorios para colocar paquetes Debian
  (archivos <filename>.deb</filename>) y añade ciertos archivos extras con información sobre
  los paquetes que se encuentran disponibles.
  </para>

  <para>
  Prar crear el repositorio, se debe crear una estructura de directorios (en este ejemplo,
  es para Ubuntu 7.04, "Feisty Fawn") en la raíz de un directorio publicado en un servidor
  web (puede ser Apache, pero generalmente yo uso <command>lighttpd</command> que es mucho más
  sencillo de configurar para pruebas). También estoy asumiendo que los paquetes de software
  son para arquitectura i386 (procesadores compatibles con Intel x86). Otras arquitecturas
  válidas que puedes ver son <filename>amd64</filename>, <filename>powerpc</filename> y
  <filename>sparc</filename>.

<programlisting><![CDATA[$ mkdir dists
$ mkdir dists/feisty
$ mkdir dists/feisty/main
$ mkdir dists/feisty/main/binary-i386 ]]></programlisting>

  Copiamos los archivos Deb (que queremos colocar en el repostorio) al directorio de destino:

<programlisting><![CDATA[$ cp /tmp/source/*.deb dists/feisty/main/binary-i386 ]]></programlisting>

  Creamos los archivos de descripción de los paquetes (llamado <filename>Packages</filename>)
  y lo comprimimos:

<programlisting><![CDATA[$ apt-ftparchive packages dists/feisty/main/binary-i386/ \
  > dists/feisty/main/binary-i386/Packages
$ cat dists/feisty/main/binary-i386/Packages | gzip -9c \
  > dists/feisty/main/binary-i386/Packages.gz ]]></programlisting>

  Creamos un archivo de descripción de nuestro repositorio, llamado <filename>apt.conf</filename>.
  Aqui reproduzco el que utilizan los desarrolladores de Automatix:

<programlisting><![CDATA[APT::FTPArchive::Release::Origin "automatix";
APT::FTPArchive::Release::Label "automatix updates";
APT::FTPArchive::Release::Suite "stable";
APT::FTPArchive::Release::Codename "feisty";
APT::FTPArchive::Release::Architectures "i386 source";
APT::FTPArchive::Release::Components "main testing";
APT::FTPArchive::Release::Description "This repository contains ..."; ]]></programlisting>

  con lo cual creamos un archivo de <filename>Release</filename>. Este archivo permite agregar
  más metadatos sobre el propósito del repositorio, las arquitecturas soportadas y la versión de
  Ubuntu o Debian para la cual queremos crear el repositorio.

<programlisting><![CDATA[$ apt-ftparchive -c apt.conf release dists/feisty/ \
  > dists/feisty/Release
]]></programlisting>

  Finalmente, utilizamos firma digital sobre este archivo de Release. Esto permitirá que,
  si hemos agregado la llave pública a nuestro depósito de firmas, el actualizador de paquetes
  valide las firmas digitales de forma automática y sin alertas de seguridad para nuestros usuarios.

  <programlisting><![CDATA[$ gpg --output dists/feisty/Release.gpg -ba dists/feisty/Release ]]></programlisting>

  Con esto, nuestro software queda disponible para que los usuarios agreguen la dirección web
  en la que hemos colocado el repositorio a su archivo <filename>/etc/apt/sources.list</filename> o
  mediante el menú <command> Sistema - Administración - Orígenes de Software - Software de Otros
  Proveedores - Agregar</command>
  y puedan instalar los paquetes de software del repositorio usando <command>apt-get install</command>
  o <command>synaptic</command>, etc.
  </para>

  <para>
  Si la carpeta raíz (donde hemos creado las carpetas <filename>dists</filename>) y las otras están
  visibles en la dirección web <filename>http://127.0.0.1/ubuntu</filename>, entonces esta dirección
  web será la dirección que deberás utilizar para la linea de APT de tu repositorio.
  </para>

  <para>
  Una linea de APT tiene la siguiente apariencia:

<programlisting><![CDATA[deb http://www.servidor.com/ruta/ release componente1 componente2 ...]]></programlisting>

  donde <command>release</command> es la versión de Ubuntu o Debian para que estamos creando el repositorio
  (en el ejemplo anterior, era <filename>feisty</filename>). Los componentes 1, 2, etc., son los diferentes
  componentes del repositorio de acuerdo a si son software libre parte de la distribución oficial
  (<command>main</command>) o son software con una licencia no libre (<command>restricted</command>),
  software libre no mantenido por Ubuntu (<command>universe</command>) o software ni libre ni mantenido por Ubuntu
 (<command>multiverse</command>). Generalmente nuestros repositorios caerán en una de las 2 últimas categorías,
  por lo que nuestros repositorios tendrán una línea de Apt como la siguiente:

  <programlisting><![CDATA[deb http://www.miservidor.com/ubuntu/ feisty universe]]></programlisting>
  </para>

  <para>
  NOTA: En el ejemplo de estructura de directorios anterior hemos usado el componente <filename>main</filename>
  para colocar nuestros paquetes de software, por lo que la línea de APT correcta será

  <programlisting><![CDATA[deb http://www.miservidor.com/ubuntu/ feisty main]]></programlisting>

  </para>

  <sect2>
  <title>Soporte para Internacionalización en los repositorios</title>

  <para>
  Ubuntu posee un amplio soporte para hacer que el sistema sea más accesible para usuarios muchos
  idiomas y eso incluye la capacidad para usar descripciones de los paquetes de software instalables
  en diferentes idiomas. La especificación del soporte para descripciones multilenguaje en los
  repositorios se encuentra en el siguiente link: <ulink url="http://wiki.ubuntu.com">Spec</ulink>
  </para>

  <para>
  Para utilizar traducciones de los paquetes de software, es necesario crear un directorio en el 
  repositorio que contenga los archivos con las traducciones de la información de paquetes:

  <programlisting><![CDATA[$ mkdir dists/gutsy/main/i18n ]]></programlisting>
  </para>

  <para>
  En este directorio se colocan diferentes archivos comprimidos que siguen la siguiente convención
  de nombres: <filename>Translation-XX.bz2</filename> donde <filename>XX</filename> es el código
  ISO de 2 letras que identifica el idioma. En el caso de las traducciones al español, será el archivo
  comprimido <filename>Translation-es.bz2</filename>
  </para>

  <para>
  El contenido del archivo será un conjunto de entradas que contienen un campo 
  <filename>Package:</filename>, un campo con la suma MD5 de la descripción original del paquete
  en la versión en inglés (<filename>Description-md5:</filename>) y la descripción en el idioma
  de la traducción (<filename>Description-es:</filename> para la versión en español).
  </para>

  <para>
  Para la traducción de mi repositorio en el que tengo el paquete <filename>gtkfilesplitter</filename>,
  el contenido del archivo <filename>dists/gutsy/main/i18n/Translation-es</filename> es
  la siguiente:

  <programlisting><![CDATA[Package: gtkfilesplitter
Description-md5: bc3667f71f65f0ffa387067d48c2a620
Description-es: Aplicación sencilla que troza y junta archivos con comprobación
 Una aplicación de escritorio para dividir archivos en trozos y volver a
 unirlos.
 .
 Para más información, visite http://code.google.com/p/gtkfilesplitter/
]]></programlisting>

  ... luego un salto de línea, y se repite para tantos paquetes como tengamos
  en el repositorio.
  </para>

  <para>
  Unos detalles adicionales para calcular la suma MD5 que se requiere colocar: La forma más
  sencilla de realizar el cálculo es crear un archivo temporal y colocar la descripción completa
  del paquete de software como viene en el archivo
  <filename>dists/gutsy/main/binary-i386/Packages</filename>, sin incluir el comienzo de la línea
  "<filename>Description: </filename>" (espacio luego de los dos puntos inclusive) de modo que quede así:

  <programlisting><![CDATA[$ cat /tmp/descripcion.txt
Simple file splitter/joiner with checksum support
 A desktop application to split and join files
 .
 For more information, visit http://code.google.com/p/gtkfilesplitter
]]></programlisting>

  </para>

  <para>
  Para calcular la suma MD5 que necesitamos para la traducción, basta con usar:

  <programlisting><![CDATA[$ md5sum /tmp/descripcion.txt
bc3667f71f65f0ffa387067d48c2a620 ]]></programlisting>

  y copiamos el valor de la suma MD5 en el campo que corresponde en nuestro archivo con
  traducciones. Finalmente, el archivo debe ir comprimido con <command>bzip2</command> de
  la siguiente forma:

  <programlisting><![CDATA[$ bzip2 dists/gutsy/main/i18n/Translation-es ]]></programlisting>

  De esta manera, las traducciones aparecen al actualizar la información de las actualizaciones
  posibles en el Gestor de Actualizaciones (Update Manager):
  </para>

  <para>
  <inlinemediaobject>
    <imageobject><imagedata fileref="img/gestor-actualizaciones1.png" format="PNG" 
     width="6in" /></imageobject>
    <textobject><phrase>Traducciones al español en las actualizaciones de software</phrase></textobject>
  </inlinemediaobject>
  </para>

  </sect2>
  </sect1>


</chapter>

