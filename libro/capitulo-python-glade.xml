<?xml version="1.0" encoding="ISO-8859-1" ?>
<!-- $Id$ -->

<chapter>
  <title>Desarrollo con Python y Glade</title>

  <sect1>
  <title>Introducción</title>

  <para>
  Hasta ahora, la combinación que me parece más atractiva para desarrollar
  aplicaciones de escritorio en Linux es la del lenguaje Python con Glade
  (como biblioteca y utilidad para crear la interfaz de usuario).
  </para>

  <para>
  En Python tenemos un lenguaje de programación maduro, con características
  de orientación a objetos pero liviano en sintaxis y que deja una buena
  cantidad de opciones a los desarrolladores responsables. De hecho, Sean
  Kelly, en un destacado videocast sobre desarrollo de aplicaciones Web habla
  de la excesiva mistificación de la encapsulación en el mundo de la orientación
  a objetos. El se refiere a los desarrolladores Python como "consenting adults"
  ("adultos con consentimiento") porque si se necesita, se puede romper la
  encapsulación con consentimiento y "tocar las partes privadas" :-)
  </para>

  <para>
  El desarrollo de una aplicación con Python y Glade es bastante sencillo:
  Primero se crean una o más clases en Python con los métodos que resuelven
  la lógica del problema que nos interesa resolver. Idealmente, deberíamos
  dejar solo un esqueleto de los métodos para tener una idea de como vamos a
  abordar el problema, para luego crear pruebas unitarias y recién ahí comenzar
  a implementar la lógica de cada método de forma de pasar sin problemas las
  pruebas unitarias.
  </para>

  <para>
  Luego, se crea una o más clases que representan la interfaz de usuario de
  la aplicación. Esta clase de interfaz de usuario utiliza un archivo XML 
  que contiene la definición de la interfaz de usuario: ventanas, barras de menú,
  botones, íconos, etc. Esta clase tiene métodos que están conectados con los eventos 
  que ocurren en la interfaz de usuario, y ejecutan cierta lógica que programamos
  en las clases que conocen la lógica de nuestro problema. 
  </para>
  </sect1>

  <sect1>
  <title>Diseño de una interfaz de usuario con Glade</title>

  <para>
  A quienes hayan utilizado entornos de desarrollo como Delphi o Visual Basic les será
  bastante familiar la idea de arrastrar controles hacia una ventalla con una grilla
  donde se pueden colocar botones, menúes y otros.
  </para>

  <para>
  <inlinemediaobject>
    <imageobject><imagedata fileref="img/glade1.png" format="PNG" width="6in" /></imageobject>
    <textobject><phrase>Glade-2 editando una interfaz de usuario</phrase></textobject>
  </inlinemediaobject>
  </para>

  <para>
  Con Glade puedes crear de forma bastante rápida un prototipo de interaz de usuario.
  Comienzas seleccionando una Ventana desde la Paleta de elementos y comienzas a
  agregarle contenedores donde puedes colocar otros elementos como menúes, cajas de
  texto y botones.
  </para>

  <para>
  Cada uno de estos elementos emite eventos cada vez que el usuario interactúa con
  ellos. Algunos ejemplos son: cuando el usuario pulsa sobre un botón o cuando una 
  tecla se presiona mientras el usuario llena un campo de texto.
  </para>

  <para>
  Al editar la interfaz de usuario en Glade, cada uno de los eventos que nos interese
  manejar deberá tener asociado un manejador, es decir, un valor que lo identifique
  de forma que nuestro programa identificará cada evento que se haya producido.
  </para>

  <para>
  Un ejemplo mínimo en Python para cargar un archivo de intefaz de usuario creado con Glade
  es uno como el siguiente, copiado desde mi proyecto GtkFileSplitter. Un archivo de interfaz
  de usuario creado con Glade puede encontrarse en esta dirección:
  <ulink url="http://gtkfilesplitter.googlecode.com/svn/trunk/gtkfilesplitter.glade">gtkfilesplitter.glade</ulink>

<programlisting><![CDATA[#!/usr/bin/env python
import pygtk
pygtk.require("2.0")
import gtk
import gtk.glade

class GtkFileSplitter:
  """GTK/Glade User interface to FileSplitter"""

  def __init__(self):

    # Cargar interfaz de usuario
    self.gladefile = "gtkfilesplitter.glade"
    self.wTree = gtk.glade.XML(self.gladefile, "GtkFileSplitter",
      'gtkfilesplitter')

    # Conectar eventos con metodos en la clase
    dic = {
      "on_splitFileButton_clicked" : self.on_splitFileButton_clicked,
      "on_FileSplitGui_destroy"    : gtk.main_quit }
    self.wTree.signal_autoconnect(dic)

  # El metodo invocado al hacer click en el Boton
  def on_splitFileButton_clicked(self, widget):
    print "Click"

if __name__ == "__main__":
  gtkfilesplitter = GtkFileSplitter()
  gtk.main()

]]></programlisting>

  En el ejemplo, se carga el archivo <filename>gtkfilesplitter.glade</filename>
  y se crea un árbol de objetos con todos los elementos de la interfaz de usuario.
  El objeto Ventana será el padre de otros objetos contenedores que a su vez serán
  padres de botones, menúes y a su vez otros contenedores...
  </para>

  <para>
  Luego, se crea un diccionario que relaciona los
  eventos definidos en la interfaz de usuario con métodos que deben estar definidos
  en la clase Python, de lo contrario, se producirá una excepción en tiempo de
  ejecución (<filename>AttributeError: GtkFileSplitter instance has no attribute 'on_splitFileButton_clicked'</filename>).
  </para>

  <para>
  En este caso, el evento <filename>on_splitFileButton_clicked</filename>, definido
  en la interfaz de usuario para el caso en que el usuario hace click en un botón,
  queda vinculado al método <filename>on_splitFileButton_clicked()</filename>
  que está definido en la clase <filename>GtkFileSplitter</filename>.
  </para>

  <para>
  <inlinemediaobject>
    <imageobject><imagedata fileref="img/glade2.png" format="PNG" width="6in"/></imageobject>
    <textobject><phrase>Detalle del evento enviado al pulsar el botón</phrase></textobject>
  </inlinemediaobject>
  </para>

  <para>
  El siguiente es el fragmento del archivo XML generado por Glade que contiene la
  definición de usuario de un botón que al ser pulsado envía el evento 
  <command>on_splitFileButton_clicked</command>

  <programlisting><![CDATA[ ...
    <child>
      <widget class="GtkButton" id="splitFileButton">
        <property name="visible">True</property>
        <property name="can_focus">True</property>
        <property name="label">gtk-ok</property>
        <property name="use_stock">True</property>
        <property name="relief">GTK_RELIEF_NORMAL</property>
        <property name="focus_on_click">True</property>
        <signal name="clicked" handler="on_splitFileButton_clicked"
         last_modification_time="Tue, 05 Dec 2006 13:35:04 GMT"/>
      </widget>
      <packing>
        <property name="padding">0</property>
        <property name="expand">False</property>
        <property name="fill">False</property>
      </packing>
    </child>
...
]]></programlisting>

  </para>

  </sect1>

  <sect1>
  <title>Soporte multilenguaje en la interfaz de usuario</title>

  <para>
  Si te has fijado en las capturas de pantalla anteriores, notarás que la interfaz de usuario
  tiene casi todos sus elementos en idioma inglés. Los únicos elementos en español que aparecen
  son los botones. Esto no es casualidad, sino una convención utilizada proveer soporte multilenguaje
  en las aplicaciones.
  </para>

  <para>
  Lo que se hace es utilizar un conjunto de archivos que proveen las traducciones de todos los
  mensajes de la interfaz de usuario de nuestra aplicación. Dependiendo de los archivos de traducciones
  que se distribuyan con el instalador, la aplicación podrá estar disponible para más idiomas. En
  este caso, utilizamos el soporte de la biblioteca GNU Gettext.
  </para>

  <para>
  En nuestro programa Python, utilizamos la función <filename>_('')</filename> sobre todos los 
  mensajes que se despliegan al usuario, de forma que

  <programlisting><![CDATA[  print ("Hola Mundo")
  s = "Error: %s (%s)" % (a, b)
]]></programlisting>

  se convierten en

  <programlisting><![CDATA[  print _("Hola Mundo")
  s = _("Error: %s (%s)") % (a, b)
]]></programlisting>

  </para>

  <para>
  Luego, para diferenciar las traducciones de nuestra aplicación de las del resto del sistema,
  utilizamos el nombre de nuestra aplicación, que debe ser diferente a las otras aplicaciones
  que se encuentren en nuestro sistema (no debe ser un nombre ambiguo).
  </para>

  <para>
  Para usar la biblioteca <command>gettext</command> desde Python, usaremos los siguientes
  imports al inicio de nuestra aplicación:

  <programlisting><![CDATA[import locale, gettext

APP = 'gtkfilesplitter'
DIR = '/usr/share/locale'

_ = gettext.gettext

try:
  import pygtk
  pygtk.require("2.0")
except:
  pass
try:
  import gtk
  import gtk.glade
except:
  sys.exit(1)

gettext.bindtextdomain(APP, DIR)
gettext.textdomain(APP)
gtk.glade.bindtextdomain(APP, DIR)
gtk.glade.textdomain(APP)
]]></programlisting>

  Para crear las traducciones utilizamos el programa xgettext, que es parte del paquete
  <filename>gettext</filename> por lo que lo instalamos con:

  <programlisting><![CDATA[$ sudo apt-get install gettext ]]></programlisting>

  Este programa nos permite extraer todos los mensajes de nuestro código fuente a un archivo
  con extensión POT (Portable Object Template), que utilizaremos como base para las traducciones
  de nuestro software.

  <programlisting><![CDATA[$ xgettext -k_ -kN_ -o messages.pot *.py ]]></programlisting>

  </para>



  </sect1>

</chapter>

