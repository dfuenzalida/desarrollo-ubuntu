<?xml version="1.0" encoding="ISO-8859-1" ?>
<!-- $Id$ -->

<chapter>
  <title>Desarrollo con Python y Glade</title>

  <sect1>
  <title>Introducción</title>

  <para>
  Hasta ahora, la combinación que me parece más atractiva para desarrollar
  aplicaciones de escritorio en Linux es la del lenguaje Python con Glade
  (como biblioteca y utilidad para crear la interfaz de usuario).
  </para>

  <para>
  En Python tenemos un lenguaje de programación maduro, con características
  de orientación a objetos pero liviano en sintaxis y que deja una buena
  cantidad de opciones a los desarrolladores responsables. De hecho, Sean
  Kelly, en un destacado videocast sobre desarrollo de aplicaciones Web habla
  de la excesiva mistificación de la encapsulación en el mundo de la orientación
  a objetos. El se refiere a los desarrolladores Python como "consenting adults"
  ("adultos con consentimiento") porque si se necesita, se puede romper la
  encapsulación con consentimiento y "tocar las partes privadas" :-)
  </para>

  <para>
  El desarrollo de una aplicación con Python y Glade es bastante sencillo:
  Primero se crean una o más clases en Python con los métodos que resuelven
  la lógica del problema que nos interesa resolver. Idealmente, deberíamos
  dejar solo un esqueleto de los métodos para tener una idea de como vamos a
  abordar el problema, para luego crear pruebas unitarias y recién ahí comenzar
  a implementar la lógica de cada método de forma de pasar sin problemas las
  pruebas unitarias.
  </para>

  <para>
  Luego, se crea una o más clases que representan la interfaz de usuario de
  la aplicación. Esta clase de interfaz de usuario utiliza un archivo XML 
  que contiene la definición de la interfaz de usuario: ventanas, barras de menú,
  botones, íconos, etc. Esta clase tiene métodos que están conectados con los eventos 
  que ocurren en la interfaz de usuario, y ejecutan cierta lógica que programamos
  en las clases que conocen la lógica de nuestro problema. 
  </para>
  </sect1>

  <sect1>
  <title>Diseño de una interfaz de usuario con Glade</title>

  <para>
  A quienes hayan utilizado entornos de desarrollo como Delphi o Visual Basic les será
  bastante familiar la idea de arrastrar controles hacia una ventalla con una grilla
  donde se pueden colocar botones, menúes y otros.
  </para>

  <para>
  <inlinemediaobject>
    <imageobject><imagedata fileref="img/glade1.png" format="PNG" width="6in" /></imageobject>
    <textobject><phrase>Glade-2 editando una interfaz de usuario</phrase></textobject>
  </inlinemediaobject>
  </para>

  <para>
  Con Glade puedes crear de forma bastante rápida un prototipo de interaz de usuario.
  Comienzas seleccionando una Ventana desde la Paleta de elementos y comienzas a
  agregarle contenedores donde puedes colocar otros elementos como menúes, cajas de
  texto y botones.
  </para>

  <para>
  Cada uno de estos elementos emite eventos cada vez que el usuario interactúa con
  ellos. Algunos ejemplos son: cuando el usuario pulsa sobre un botón o cuando una 
  tecla se presiona mientras el usuario llena un campo de texto.
  </para>

  <para>
  Al editar la interfaz de usuario en Glade, cada uno de los eventos que nos interese
  manejar deberá tener asociado un manejador, es decir, un valor que lo identifique
  de forma que nuestro programa identificará cada evento que se haya producido.
  </para>

  <para>
  Un ejemplo mínimo en Python para cargar un archivo de intefaz de usuario creado con Glade
  es uno como el siguiente, copiado desde mi proyecto GtkFileSplitter. Un archivo de interfaz
  de usuario creado con Glade puede encontrarse en esta dirección:
  <ulink url="http://gtkfilesplitter.googlecode.com/svn/trunk/gtkfilesplitter.glade">gtkfilesplitter.glade</ulink>

<programlisting><![CDATA[#!/usr/bin/env python
import pygtk
pygtk.require("2.0")
import gtk
import gtk.glade

class GtkFileSplitter:
  """GTK/Glade User interface to FileSplitter"""

  def __init__(self):

    # Cargar interfaz de usuario
    self.gladefile = "gtkfilesplitter.glade"
    self.wTree = gtk.glade.XML(self.gladefile, "GtkFileSplitter",
      'gtkfilesplitter')

    # Conectar eventos con metodos en la clase
    dic = {
      "on_splitFileButton_clicked" : self.on_splitFileButton_clicked,
      "on_FileSplitGui_destroy"    : gtk.main_quit }
    self.wTree.signal_autoconnect(dic)

  # El metodo invocado al hacer click en el Boton
  def on_splitFileButton_clicked(self, widget):
    print "Click"

if __name__ == "__main__":
  gtkfilesplitter = GtkFileSplitter()
  gtk.main()

]]></programlisting>

  En el ejemplo, se carga el archivo <filename>gtkfilesplitter.glade</filename>
  y se crea un árbol de objetos con todos los elementos de la interfaz de usuario.
  El objeto Ventana será el padre de otros objetos contenedores que a su vez serán
  padres de botones, menúes y a su vez otros contenedores...
  </para>

  <para>
  Luego, se crea un diccionario que relaciona los
  eventos definidos en la interfaz de usuario con métodos que deben estar definidos
  en la clase Python, de lo contrario, se producirá una excepción en tiempo de
  ejecución (<filename>AttributeError: GtkFileSplitter instance has no attribute 'on_splitFileButton_clicked'</filename>).
  </para>

  <para>
  En este caso, el evento <filename>on_splitFileButton_clicked</filename>, definido
  en la interfaz de usuario para el caso en que el usuario hace click en un botón,
  queda vinculado al método <filename>on_splitFileButton_clicked()</filename>
  que está definido en la clase <filename>GtkFileSplitter</filename>.
  </para>

  <para>
  <inlinemediaobject>
    <imageobject><imagedata fileref="img/glade2.png" format="PNG" width="6in"/></imageobject>
    <textobject><phrase>Detalle del evento enviado al pulsar el botón</phrase></textobject>
  </inlinemediaobject>
  </para>

  <para>
  El siguiente es el fragmento del archivo XML generado por Glade que contiene la
  definición de usuario de un botón que al ser pulsado envía el evento 
  <command>on_splitFileButton_clicked</command>

  <programlisting><![CDATA[ ...
    <child>
      <widget class="GtkButton" id="splitFileButton">
        <property name="visible">True</property>
        <property name="can_focus">True</property>
        <property name="label">gtk-ok</property>
        <property name="use_stock">True</property>
        <property name="relief">GTK_RELIEF_NORMAL</property>
        <property name="focus_on_click">True</property>
        <signal name="clicked" handler="on_splitFileButton_clicked"
         last_modification_time="Tue, 05 Dec 2006 13:35:04 GMT"/>
      </widget>
      <packing>
        <property name="padding">0</property>
        <property name="expand">False</property>
        <property name="fill">False</property>
      </packing>
    </child>
...
]]></programlisting>

  </para>

  </sect1>

  <sect1>
  <title>Soporte multilenguaje en la interfaz de usuario</title>

  <para>
  Si te has fijado en las capturas de pantalla anteriores, notarás que la interfaz de usuario
  tiene casi todos sus elementos en idioma inglés. Los únicos elementos en español que aparecen
  son los botones. Esto no es casualidad, sino una convención utilizada proveer soporte multilenguaje
  en las aplicaciones.
  </para>

  <para>
  Lo que se hace es utilizar un conjunto de archivos que proveen las traducciones de todos los
  mensajes de la interfaz de usuario de nuestra aplicación. Dependiendo de los archivos de traducciones
  que se distribuyan con el instalador, la aplicación podrá estar disponible para más idiomas. En
  este caso, utilizamos el soporte de la biblioteca GNU Gettext.
  </para>

  <para>
  En nuestro programa Python, utilizamos la función <filename>_('')</filename> sobre todos los 
  mensajes que se despliegan al usuario, de forma que

  <programlisting><![CDATA[  print ("Hola Mundo")
  s = "Error: %s (%s)" % (a, b)
]]></programlisting>

  se convierten en

  <programlisting><![CDATA[  print _("Hola Mundo")
  s = _("Error: %s (%s)") % (a, b)
]]></programlisting>

  </para>

  <para>
  Luego, para diferenciar las traducciones de nuestra aplicación de las del resto del sistema,
  utilizamos el nombre de nuestra aplicación, que debe ser diferente a las otras aplicaciones
  que se encuentren en nuestro sistema (no debe ser un nombre ambiguo).
  </para>

  <para>
  Para usar la biblioteca <command>gettext</command> desde Python, importaremos las bibliotecas
  <filename>locale</filename> y <filename>gettext</filename> al inicio de nuestra aplicación.
  El inicio de nuestro programa quedará como el siguiente:

  <programlisting><![CDATA[import locale, gettext

APP = 'gtkfilesplitter'
DIR = 'locale'

# Mapeo la funcion gettext.gettext como "_"
_ = gettext.gettext

try:
  import pygtk
  # Para usar la versión 2.0 de pygtk
  pygtk.require("2.0")
except:
  pass
try:
  import gtk
  import gtk.glade
except:
  sys.exit(1)

# Enlazo las traducciones de la aplicación e interfaz de usuario
gettext.bindtextdomain(APP, DIR)
gettext.textdomain(APP)
gtk.glade.bindtextdomain(APP, DIR)
gtk.glade.textdomain(APP)
]]></programlisting>

  Para crear las traducciones utilizamos el programa xgettext, que es parte del paquete
  <filename>gettext</filename> por lo que lo instalamos con:

  <programlisting><![CDATA[$ sudo apt-get install gettext ]]></programlisting>

  Este programa nos permite extraer todos los mensajes de nuestro código fuente a un archivo
  con extensión POT (Portable Object Template), que utilizaremos como base para las traducciones
  de nuestro software.
  
  <!-- TODO: Revisar  intltool-extract __type=gettext/glade foo.glade -->

  <programlisting><![CDATA[$ xgettext -k_ -kN_ -o messages.pot *.py *.glade]]></programlisting>

  Este archivo <filename>messages.pot</filename> contiene todos los mensajes que es posible
  traducir, y tiene una apariencia como la siguiente:

  <programlisting><![CDATA[# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2006-12-13 22:47-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#: gtkfilesplitter.py:551
#, python-format
msgid "Working ... %d%c done"
msgstr ""

#: gtkfilesplitter.py:385 gtkfilesplitter.py:511
msgid "Do you want to cancel?"
msgstr ""

#: gtkfilesplitter.glade.h:7
msgid "Delete original file?"
msgstr ""

...
  ]]></programlisting>

  Cada mensaje identificado como "traducible" aparece en un item <filename>msgid</filename> junto
  con una traducción vacía en la línea siguiente, después de <filename>msgstr</filename>.
  </para>

  <para>
  Para comenzar a traducir, utilizamos el siguiente comando:

  <programlisting><![CDATA[$ msginit --input messages.pot 
created es.po]]></programlisting>

  El idioma se obtiene del valor de la variable de ambiente <filename>LANG</filename>, y
  en el caso de un sistema con idioma español, será <filename>es.po</filename>.
  Editamos el archivo para agregar nuestras traducciones y modificamos el preámbulo del
  mismo con información de contacto del traductor:

  <programlisting><![CDATA[# Messages Translation File for GtkFileSplitter
# Copyright (C) 2006 Denis Fuenzalida
# This file is distributed under the GPL license
# Denis Fuenzalida <denis.fuenzalida@gmail.com>, 2006
# 
msgid ""
msgstr ""
"Project-Id-Version: gtkfilesplitter 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2006-12-13 22:47-0300\n"
"PO-Revision-Date: 2006-12-07 10:32-0300\n"
"Last-Translator: <denis.fuenzalida@gmail.com>\n"
"Language-Team: Spanish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CP1252\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: gtkfilesplitter.py:551
#, python-format
msgid "Working ... %d%c done"
msgstr "Trabajando ... %d%c listo"

#: gtkfilesplitter.py:385 gtkfilesplitter.py:511
msgid "Do you want to cancel?"
msgstr "¿Desea cancelar la operación?"

#: gtkfilesplitter.glade.h:7
msgid "Delete original file?"
msgstr "¿Borrar el archivo original?"

...

]]></programlisting>

  Al inicio del código fuente del programa se definió la constante <filename>DIR</filename> que
  indica el directorio en el que se encuentran los archivos con las traducciones. Los archivos
  con las traducciones no se utilizan directamente como texto plano sino que se convierten a
  un formato binario con extensión <filename>.mo</filename>. Para colocar la traducción al
  español creamos una estructura de directorios predefinida:

  <programlisting><![CDATA[$ mkdir locale
$ mkdir locale/es
$ mkdir locale/es/LC_MESSAGES
$ msgfmt es.po -o locale/es/LC_MESSAGES/gtkfilesplitter.mo
]]></programlisting>

  Es importante ser consistente en el uso de los nombres de archivos, de lo contrario, la
  traducción no se encontrará y la interfaz de usuario aparecerá en inglés en lugar de la
  esperada. En este caso, el archivo <filename>.mo</filename> esperado
  es el mismo que aparece en el código fuente en la constante <filename>APP</filename>.
  </para>

  <para>
  Si todo ha salido bien, podrás iniciar tu aplicación en el idioma deseado, e incluso
  indicar otros idiomas diferentes al que tengas configurado, reemplazando el valor de
  la variable de ambiente <filename>LANG</filename> al momento de iniciar la aplicación.
  Por ejemplo, para iniciar mi aplicación <command>gtkfilesplitter</command>
  en idioma inglés basta con iniciarla en un Terminal con:

  <programlisting><![CDATA[$ LANG=en gtkfilesplitter ]]></programlisting>

  En la siguiente imagen se muestra la misma aplicación ejecutándose con dos idiomas
  distintos:
  
  <inlinemediaobject>
    <imageobject><imagedata fileref="img/gtkfilesplitter-en-es.png" format="PNG" width="6in"/></imageobject>
    <textobject><phrase>Interfaz de usuario en Inglés y Español</phrase></textobject>
  </inlinemediaobject>
  </para>

  </sect1>

</chapter>

